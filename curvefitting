import numpy as np
import pandas as pd
from scipy.optimize import minimize, minimize_scalar, differential_evolution
from pathlib import Path
import time

# --- 1. Load data ---
df = pd.read_csv("xy_data.csv")
x_obs = df.iloc[:,0].to_numpy(float)
y_obs = df.iloc[:,1].to_numpy(float)
N = len(x_obs)
print(f"Loaded {N} points")

# --- 2. Parametric model ---
def curve_xy(t, theta_deg, M, X):
    theta = np.deg2rad(theta_deg)
    exp_term = np.exp(M * np.abs(t))
    s = np.sin(0.3 * t)
    x = t * np.cos(theta) - exp_term * s * np.sin(theta) + X
    y = 42.0 + t * np.sin(theta) + exp_term * s * np.cos(theta)
    return x, y

# --- 3. Per-point nested minimization ---
def min_sq_distance_to_point(xi, yi, theta_deg, M, X, t_bounds=(6.0,60.0)):
    def d2(t):
        xp, yp = curve_xy(t, theta_deg, M, X)
        return (xp - xi)**2 + (yp - yi)**2
    res = minimize_scalar(d2, bounds=t_bounds, method='bounded',
                          options={'xatol':1e-12, 'maxiter':1000})
    return res.x, res.fun

# --- 4. Objective function ---
def objective(params):
    theta_deg, M, X = params
    # Bound check
    if not (0.0 < theta_deg < 50.0 and -0.05 < M < 0.05 and 0.0 < X < 100.0):
        return 1e10
    total = 0.0
    for xi, yi in zip(x_obs, y_obs):
        _, d2min = min_sq_distance_to_point(xi, yi, theta_deg, M, X)
        total += d2min
    return total

# --- 5. Global optimization ---
bounds = [(1e-6, 49.9999), (-0.0499, 0.0499), (1e-6, 99.9999)]
print("ðŸŒ Running global Differential Evolution for robustness...")
t0 = time.time()
de_res = differential_evolution(objective, bounds, strategy='best1bin',
                                popsize=25, maxiter=2000, tol=1e-8,
                                mutation=(0.5,1.0), recombination=0.9,
                                polish=False, disp=True)
t1 = time.time()
print(f"DE completed in {t1-t0:.2f}s, best params:", de_res.x)

# --- 6. Local refinement ---
print("ðŸ” Refining with high-precision L-BFGS-B...")
local_res = minimize(objective, de_res.x, method='L-BFGS-B',
                     bounds=bounds,
                     options={'ftol':1e-14, 'gtol':1e-10, 'maxiter':1000})
t2 = time.time()
print(f"Local refinement done in {t2-t1:.2f}s")

theta_fit, M_fit, X_fit = local_res.x
print(f"\nFinal parameters:\n  Î¸ = {theta_fit:.10f}Â°\n  M = {M_fit:.10e}\n  X = {X_fit:.10f}")

# --- 7. Per-point t_i re-evaluation ---
t_fitted = np.empty(N)
d2_fitted = np.empty(N)
for i, (xi, yi) in enumerate(zip(x_obs, y_obs)):
    t_star, d2min = min_sq_distance_to_point(xi, yi, theta_fit, M_fit, X_fit)
    t_fitted[i] = t_star
    d2_fitted[i] = d2min

rms = np.sqrt(np.mean(d2_fitted))
print(f"âœ… RMS distance = {rms:.12e}")
print(f"Total time = {time.time()-t0:.2f}s")

# --- 8. Save results ---
pd.DataFrame({
    "x_obs": x_obs, "y_obs": y_obs,
    "t_fit": t_fitted, "d2": d2_fitted
}).to_csv("xy_with_t_fit_highprecision.csv", index=False)
with open("fit_result_summary.txt", "w") as f:
    f.write(f"theta_deg={theta_fit}\nM={M_fit}\nX={X_fit}\nRMS={rms}\n")
print("Results saved to xy_with_t_fit_highprecision.csv and fit_result_summary.txt")
