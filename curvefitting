#1
import numpy as np
import pandas as pd
from pathlib import Path
from scipy.optimize import minimize, minimize_scalar, differential_evolution
import time

#2
dt = Path("xy_data.csv")
if not dt.exists():
    raise FileNotFoundError(f"CSV not found: {dt}")

df = pd.read_csv(dt)
x_obs = df.iloc[:, 0].to_numpy(dtype=float)
y_obs = df.iloc[:, 1].to_numpy(dtype=float)
N = len(x_obs)
print(f"Loaded {N} data points.")

#3
def curve_xy(t, theta_deg, M, X):
    theta = np.deg2rad(theta_deg)
    exp_term = np.exp(M * np.abs(t))
    s = np.sin(0.3 * t)
    x = t * np.cos(theta) - exp_term * s * np.sin(theta) + X
    y = 42.0 + t * np.sin(theta) + exp_term * s * np.cos(theta)
    return x, y

#4
def min_sq_distance_to_point_fast(xi, yi, theta_deg, M, X, t_bounds=(6.0, 60.0), num_t=2000):
    t_grid = np.linspace(t_bounds[0], t_bounds[1], num_t)
    xg, yg = curve_xy(t_grid, theta_deg, M, X)
    d2 = (xg - xi) ** 2 + (yg - yi) ** 2
    idx = np.argmin(d2)
    return t_grid[idx], d2[idx]

#5
def objective(params):
    theta_deg, M, X = params
    if not (0.0 < theta_deg < 50.0 and -0.05 < M < 0.05 and 0.0 < X < 100.0):
        return 1e12  
    total = 0.0
    for xi, yi in zip(x_obs, y_obs):
        _, d2min = min_sq_distance_to_point_fast(xi, yi, theta_deg, M, X)
        total += d2min
    return total

#6
bounds = [(1e-6, 50.0 - 1e-6), (-0.049999, 0.049999), (1e-6, 100.0 - 1e-6)]

print("\nStage 1: Global search (Differential Evolution)...")
t1 = time.time()
res_global = differential_evolution(objective, bounds, maxiter=80, tol=1e-4, polish=False, updating="deferred")
t2 = time.time()
print(f"  Global search complete in {t2 - t1:.2f}s")

print("\nStage 2: Local refinement (L-BFGS-B)...")
res_local = minimize(objective, res_global.x, method="L-BFGS-B", bounds=bounds,
                     options={'ftol': 1e-12, 'maxiter': 400})
t3 = time.time()
print(f"  Local refinement complete in {t3 - t2:.2f}s")

theta_fit, M_fit, X_fit = res_local.x
print(f"\n Fitted parameters:")
print(f"   θ = {theta_fit:.8f}°")
print(f"   M = {M_fit:.8e}")
print(f"   X = {X_fit:.8f}")
print(f"   Objective = {res_local.fun:.6e}")

#7
t_fitted = np.empty(N)
d2_fitted = np.empty(N)
for i, (xi, yi) in enumerate(zip(x_obs, y_obs)):
    t_star, d2min = min_sq_distance_to_point_fast(xi, yi, theta_fit, M_fit, X_fit)
    t_fitted[i], d2_fitted[i] = t_star, d2min

rms = np.sqrt(np.mean(d2_fitted))
print(f"\n RMS = {rms:.6e}")
print(f"t range: {t_fitted.min():.6f} – {t_fitted.max():.6f}")
print(f"Total CPU time: {t3 - t1:.2f}s")

#8
out_df = pd.DataFrame({'x_obs': x_obs, 'y_obs': y_obs, 't_fit': t_fitted, 'd2': d2_fitted})
out_df.to_csv("xy_with_t.csv", index=False)
with open("result.txt", "w") as f:
    f.write(f"theta_deg={theta_fit}\nM={M_fit}\nX={X_fit}\nObjective={res_local.fun}\nRMS={rms}\n")

print("\nResults saved in 'xy_with_t.csv' and 'result.txt'")

#9
x_pred, y_pred = curve_xy(t_fitted, theta_fit, M_fit, X_fit)
l1_per_point = np.abs(x_obs - x_pred) + np.abs(y_obs - y_pred)
L1_total = np.sum(l1_per_point)
L1_mean = np.mean(l1_per_point)
print(f"L1 total distance = {L1_total:.6f}")
print(f"L1 mean distance  = {L1_mean:.6f}")
